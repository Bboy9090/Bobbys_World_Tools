Python api_cli.py ‚Üí JSON interface around your Dev Mode CLI

Tauri commands (Rust) ‚Üí bridge to UI

React DevModeTab.tsx ‚Üí dropdowns for profile/module + output pane

1Ô∏è‚É£ Python: bobby_dev_mode/api_cli.py

This wraps your existing modules in a JSON-friendly way instead of the human CLI output.

Create bobby_dev_mode/api_cli.py:

# bobby_dev_mode/api_cli.py

import json
import os
import sys
from io import StringIO
from contextlib import redirect_stdout

from .modules import MODULES

BASE_DIR = os.path.dirname(__file__)
PROFILE_DIR = os.path.join(BASE_DIR, "profiles")


def load_profile(name: str) -> dict:
    path = os.path.join(PROFILE_DIR, f"{name}.json")
    if not os.path.isfile(path):
        raise FileNotFoundError(f"Profile not found: {path}")
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def list_profiles_json():
    profiles = []
    for fname in sorted(os.listdir(PROFILE_DIR)):
        if not fname.endswith(".json"):
            continue
        name = fname[:-5]
        with open(os.path.join(PROFILE_DIR, fname), "r", encoding="utf-8") as f:
            data = json.load(f)
        profiles.append({
            "id": name,
            "name": data.get("name", name),
            "brand": data.get("brand", "Unknown"),
            "notes": data.get("notes", "")
        })
    print(json.dumps(profiles))


def run_module_json(profile_name: str, module: str):
    profile = load_profile(profile_name)
    module = module.lower()

    if module == "all":
        modules_order = ["dossier", "warhammer", "darklab", "forbidden", "fastboot", "recovery"]
        selected = [m for m in modules_order if m in MODULES]
    else:
        if module not in MODULES:
            print(json.dumps({"error": f"Unknown module: {module}"}))
            return
        selected = [module]

    buf = StringIO()
    with redirect_stdout(buf):
        print(f"=== BOBBY DEV MODE ===")
        print(f"Profile: {profile.get('name', profile_name)}")
        print(f"Brand:   {profile.get('brand', 'Unknown')}")
        print(f"Notes:   {profile.get('notes', '')}")
        print("")

        for m in selected:
            fn = MODULES[m]
            print(f"\n########## MODULE: {m.upper()} ##########\n")
            fn(profile)

    output = buf.getvalue()
    print(json.dumps({
        "profile": profile_name,
        "module": module,
        "output": output,
    }))


def main():
    if len(sys.argv) < 2:
        print("Usage: api_cli.py <command> [...]")
        sys.exit(1)

    cmd = sys.argv[1]

    if cmd == "list_profiles_json":
        list_profiles_json()
    elif cmd == "run_module_json":
        if len(sys.argv) < 4:
            print(json.dumps({"error": "Need profile and module"}))
            sys.exit(1)
        profile = sys.argv[2]
        module = sys.argv[3]
        run_module_json(profile, module)
    else:
        print(json.dumps({"error": f"Unknown command: {cmd}"}))
        sys.exit(1)


if __name__ == "__main__":
    main()


That gives you:

python -m bobby_dev_mode.api_cli list_profiles_json

python -m bobby_dev_mode.api_cli run_module_json moto_g_play_23 all

returning clean JSON.

2Ô∏è‚É£ Tauri: Rust bridge functions

In src-tauri/src/main.rs, you already have a run_python helper in earlier designs. Reuse that:

#[tauri::command]
fn devmode_list_profiles() -> Result<String, String> {
    // python -m bobby_dev_mode.api_cli list_profiles_json
    run_python("-m", &["bobby_dev_mode.api_cli", "list_profiles_json"])
}

#[tauri::command]
fn devmode_run_module(profile: String, module: String) -> Result<String, String> {
    // python -m bobby_dev_mode.api_cli run_module_json <profile> <module>
    run_python(
        "-m",
        &["bobby_dev_mode.api_cli", "run_module_json", &profile, &module],
    )
}


If your run_python signature was run_python(cmd: &str, args: &[&str]), then above is consistent: first arg is "-m", rest are the module + subcommand.

Wire them into the handler:

.invoke_handler(tauri::generate_handler![
    // existing commands...
    devmode_list_profiles,
    devmode_run_module,
])


Now the frontend can call:

invoke("devmode_list_profiles") ‚Üí JSON array of profiles

invoke("devmode_run_module", { profile, module }) ‚Üí JSON with output string

3Ô∏è‚É£ React: DevModeTab.tsx

Create src/tabs/DevModeTab.tsx:

import { useEffect, useState } from "react";
import { invoke } from "@tauri-apps/api/tauri";

type DevProfile = {
  id: string;
  name: string;
  brand: string;
  notes: string;
};

const MODULE_OPTIONS = [
  { value: "all", label: "All Modules" },
  { value: "dossier", label: "Device Dossier" },
  { value: "warhammer", label: "Debloat Warhammer" },
  { value: "darklab", label: "Dark Lab (Thermal / I/O / CPU)" },
  { value: "forbidden", label: "Forbidden Chamber (Security)" },
  { value: "fastboot", label: "Fastboot / Flash Arsenal" },
  { value: "recovery", label: "Recovery Ops" },
];

export function DevModeTab() {
  const [profiles, setProfiles] = useState<DevProfile[]>([]);
  const [profileId, setProfileId] = useState<string>("");
  const [module, setModule] = useState<string>("all");
  const [output, setOutput] = useState<string>("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string>("");

  useEffect(() => {
    (async () => {
      try {
        const raw = await invoke<string>("devmode_list_profiles");
        const data = JSON.parse(raw) as DevProfile[];
        setProfiles(data);
        if (data.length > 0) {
          setProfileId(data[0].id);
        }
      } catch (e: any) {
        setError(String(e));
      }
    })();
  }, []);

  async function run() {
    if (!profileId) return;
    setLoading(true);
    setError("");
    setOutput("");
    try {
      const raw = await invoke<string>("devmode_run_module", {
        profile: profileId,
        module,
      });
      const res = JSON.parse(raw) as { output?: string; error?: string };
      if (res.error) {
        setError(res.error);
      }
      if (res.output) {
        setOutput(res.output);
      }
    } catch (e: any) {
      setError(String(e));
    } finally {
      setLoading(false);
    }
  }

  const currentProfile = profiles.find((p) => p.id === profileId);

  return (
    <div className="flex flex-col gap-3 h-full">
      {/* Controls row */}
      <div className="flex flex-wrap gap-3 items-end">
        <div className="min-w-[220px]">
          <label className="block text-xs text-slate-400 mb-1">
            Profile (Device)
          </label>
          <select
            className="w-full bg-slate-900 border border-slate-700 rounded-md px-2 py-1 text-xs"
            value={profileId}
            onChange={(e) => setProfileId(e.target.value)}
          >
            {profiles.length === 0 && (
              <option value="">No profiles found</option>
            )}
            {profiles.map((p) => (
              <option key={p.id} value={p.id}>
                {p.brand} ‚Äì {p.name}
              </option>
            ))}
          </select>
        </div>

        <div className="min-w-[220px]">
          <label className="block text-xs text-slate-400 mb-1">
            Module
          </label>
          <select
            className="w-full bg-slate-900 border border-slate-700 rounded-md px-2 py-1 text-xs"
            value={module}
            onChange={(e) => setModule(e.target.value)}
          >
            {MODULE_OPTIONS.map((m) => (
              <option key={m.value} value={m.value}>
                {m.label}
              </option>
            ))}
          </select>
        </div>

        <button
          onClick={run}
          disabled={!profileId || loading}
          className="px-4 py-2 rounded-md bg-emerald-600 hover:bg-emerald-500 text-sm disabled:opacity-50"
        >
          {loading ? "Running‚Ä¶" : "Run Dev Mode"}
        </button>

        {error && (
          <div className="text-xs text-red-400 max-w-xs">
            {error}
          </div>
        )}
      </div>

      {/* Profile notes */}
      {currentProfile && (
        <div className="border border-slate-800 rounded-xl p-2 text-xs text-slate-300 bg-slate-950/60">
          <div className="flex justify-between">
            <div>
              <span className="font-semibold">{currentProfile.name}</span>{" "}
              <span className="text-slate-400">
                ({currentProfile.brand})
              </span>
            </div>
          </div>
          {currentProfile.notes && (
            <div className="mt-1 text-[11px] text-slate-400">
              {currentProfile.notes}
            </div>
          )}
        </div>
      )}

      {/* Output window */}
      <div className="flex-1 border border-slate-800 rounded-xl overflow-hidden flex flex-col">
        <div className="px-3 py-2 text-xs text-slate-400 border-b border-slate-800">
          Console Output
        </div>
        <pre className="flex-1 bg-slate-950 text-[11px] p-3 overflow-auto whitespace-pre-wrap">
          {output || "Run a profile/module to see output here."}
        </pre>
      </div>
    </div>
  );
}

4Ô∏è‚É£ Hook Tab into the main app

In src/App.tsx (or wherever your main UI switch is):

Import the tab:

import { DevModeTab } from "./tabs/DevModeTab";


Add a tab button:

type TabKey = "drives" | "imaging" | "diagnostics" | "jobs" | "console" | "devmode";


Nav:

<button
  onClick={() => setTab("devmode")}
  className={`px-3 py-1 rounded-md ${
    tab === "devmode" ? "bg-slate-800" : "hover:bg-slate-900"
  }`}
>
  Dev Mode
</button>


Render the tab:

{tab === "devmode" && <DevModeTab />}


Now you‚Äôve got:

All your Bobby Dev Mode logic in one CLI

A JSON API layer for Tauri

A Dev Mode panel in the app:

Pick profile (Moto G Play 23, S22+, Pixel, etc.)

Pick module (Dossier / Warhammer / Dark Lab / etc.)

Click run ‚Üí see full terminal-style output

If you want to go even harder later, we can:

Add per-command streaming output (live scroll while ADB runs)

Add one-click ADB log export per run

Or wire Dev Mode outputs into your Case Files / History system.

You said:
yea go all
ChatGPT said:
Thought for 53s

Cool. Let‚Äôs flip everything on:

Live streaming Dev Mode output

Run-and-save into Case Files

Text log export button

I‚Äôll give you delta patches, not theory.

1Ô∏è‚É£ Live Streaming Dev Mode Output

We‚Äôll stream stdout from the CLI instead of waiting for JSON.

A. Tauri command: devmode_stream_module

In src-tauri/src/main.rs:

use std::process::{Command, Stdio};
use std::io::{BufRead, BufReader};
use tauri::Window;

// existing run_python etc‚Ä¶

#[tauri::command]
fn devmode_stream_module(window: Window, profile: String, module: String) -> Result<(), String> {
    // python -m bobby_dev_mode.cli --profile <profile> --module <module>
    let mut child = Command::new("python")
        .arg("-m")
        .arg("bobby_dev_mode.cli")
        .arg("--profile")
        .arg(&profile)
        .arg("--module")
        .arg(&module)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|e| format!("Failed to spawn devmode: {e}"))?;

    let stdout = child.stdout.take().ok_or("No stdout from devmode")?;
    let stderr = child.stderr.take();

    // Stream STDOUT
    let win_clone = window.clone();
    tauri::async_runtime::spawn(async move {
        let reader = BufReader::new(stdout);
        for line in reader.lines() {
            if let Ok(l) = line {
                let _ = win_clone.emit("devmode-output", l);
            }
        }
    });

    // Optionally also stream STDERR into same channel (tagged)
    if let Some(err) = stderr {
        let win_clone2 = window.clone();
        tauri::async_runtime::spawn(async move {
            let reader = BufReader::new(err);
            for line in reader.lines() {
                if let Ok(l) = line {
                    let _ = win_clone2.emit("devmode-output", format!("[ERR] {l}"));
                }
            }
        });
    }

    Ok(())
}


Add to invoke_handler!:

.invoke_handler(tauri::generate_handler![
    // ‚Ä¶other commands‚Ä¶
    devmode_list_profiles,
    devmode_run_module,
    devmode_stream_module,
])

B. DevModeTab: add streaming mode

Modify DevModeTab.tsx:

add state:

import { listen } from "@tauri-apps/api/event";

const [live, setLive] = useState(false);
const [streaming, setStreaming] = useState(false);


Add useEffect to subscribe to devmode-output:

useEffect(() => {
  let unlistenPromise: Promise<()>;
  if (live) {
    unlistenPromise = listen<string>("devmode-output", (event) => {
      const line = event.payload;
      // append line
      setOutput((prev) => (prev ? prev + "\n" + line : line));
    }).then((unlisten) => {
      // return cleanup
      return () => unlisten();
    });
  }

  return () => {
    if (unlistenPromise) {
      unlistenPromise.then((cleanup) => cleanup && cleanup());
    }
  };
}, [live]);


(If your tooling complains, you can wrap that pattern slightly differently, but idea is clear: subscribe when live is true.)

Add two run functions:

async function runJsonMode() {
  if (!profileId) return;
  setLoading(true);
  setError("");
  setOutput("");
  try {
    const raw = await invoke<string>("devmode_run_module", {
      profile: profileId,
      module,
    });
    const res = JSON.parse(raw) as { output?: string; error?: string; ticket_id?: string };
    if (res.error) setError(res.error);
    if (res.output) setOutput(res.output);
    // Optional: show ticket ID if we wire case saving (next section)
    if (res.ticket_id) {
      setOutput((prev) => (prev ? prev + `\n\n[Saved as case ${res.ticket_id}]` : prev));
    }
  } catch (e: any) {
    setError(String(e));
  } finally {
    setLoading(false);
  }
}

async function runLive() {
  if (!profileId) return;
  setStreaming(true);
  setError("");
  setOutput("");
  try {
    await invoke("devmode_stream_module", {
      profile: profileId,
      module,
    });
    // process continues async; output comes via events
  } catch (e: any) {
    setError(String(e));
    setStreaming(false);
  }
}


Update controls row:

<div className="flex flex-wrap gap-3 items-end">
  {/* profile select, module select ... */}

  <div className="flex items-center gap-2">
    <label className="flex items-center gap-1 text-xs text-slate-400">
      <input
        type="checkbox"
        checked={live}
        onChange={(e) => setLive(e.target.checked)}
      />
      Live stream mode
    </label>
  </div>

  <button
    onClick={live ? runLive : runJsonMode}
    disabled={!profileId || loading || streaming}
    className="px-4 py-2 rounded-md bg-emerald-600 hover:bg-emerald-500 text-sm disabled:opacity-50"
  >
    {live
      ? streaming
        ? "Streaming‚Ä¶"
        : "Run Dev Mode (Live)"
      : loading
        ? "Running‚Ä¶"
        : "Run Dev Mode"}
  </button>
</div>


Now you have two modes:

JSON mode (non-live) ‚Äî used for history & export

Live mode ‚Äî raw CLI streamed into the pane

2Ô∏è‚É£ Dev Mode ‚Üí Case Files / History

We‚Äôll make non-live runs automatically write a DEV- case into the existing history.manager.

A. Extend history/manager.py

Add an optional kind and allow arbitrary payload:

# history/manager.py (add this helper)

from datetime import datetime

def save_devmode_run(profile: dict, module: str, output: str) -> str:
    """
    Save Dev Mode run as a case file and return ticket_id.
    """
    ts = datetime.utcnow().strftime("%Y%m%d-%H%M%S")
    ticket_id = f"DEV-{ts}"

    payload = {
        "ticket_id": ticket_id,
        "kind": "devmode",
        "profile_id": profile.get("id"),
        "profile_name": profile.get("name"),
        "brand": profile.get("brand"),
        "module": module,
        "output": output,
        "device_hint": profile.get("model_hint"),
        "timestamp": datetime.utcnow().isoformat() + "Z",
    }
    save_case(ticket_id, payload)
    return ticket_id


save_case is the same function we already made earlier; this just piggybacks on it.

B. Modify bobby_dev_mode/api_cli.py

Change run_module_json:

# bobby_dev_mode/api_cli.py

from datetime import datetime
from io import StringIO
from contextlib import redirect_stdout

from ..history.manager import save_devmode_run  # adjust relative path as needed

def run_module_json(profile_name: str, module: str):
    profile = load_profile(profile_name)
    module = module.lower()

    if module == "all":
        modules_order = ["dossier", "warhammer", "darklab", "forbidden", "fastboot", "recovery"]
        selected = [m for m in modules_order if m in MODULES]
    else:
        if module not in MODULES:
            print(json.dumps({"error": f"Unknown module: {module}"}))
            return
        selected = [module]

    buf = StringIO()
    with redirect_stdout(buf):
        print(f"=== BOBBY DEV MODE ===")
        print(f"Profile: {profile.get('name', profile_name)}")
        print(f"Brand:   {profile.get('brand', 'Unknown')}")
        print(f"Notes:   {profile.get('notes', '')}")
        print("")

        for m in selected:
            fn = MODULES[m]
            print(f"\n########## MODULE: {m.upper()} ##########\n")
            fn(profile)

    output = buf.getvalue()

    # üî• Save as DevMode case
    # Ensure profile has "id" field for history; if not, inject.
    if "id" not in profile:
        profile["id"] = profile_name
    ticket_id = save_devmode_run(profile, module, output)

    print(json.dumps({
        "profile": profile_name,
        "module": module,
        "output": output,
        "ticket_id": ticket_id,
    }))


Now every JSON-mode run:

Executes DevMode

Captures output

Writes a DEV-YYYYMMDD-HHMMSS case in history/storage

Returns that ticket_id to the frontend

DevMode runs will now show up in your existing Jobs / Case Files panel.

The DevModeTab JSON run button already parses ticket_id (we added it) and can annotate the console text with [Saved as case DEV-‚Ä¶].

3Ô∏è‚É£ Export Dev Mode Log as Text File

For quick exports, we‚Äôll do it in Rust only, no Python.

A. Tauri command: devmode_export_log

In src-tauri/src/main.rs:

use std::fs;
use std::path::PathBuf;
use chrono::Utc; // add chrono = "0.4" to Cargo.toml if not present

#[tauri::command]
fn devmode_export_log(profile: String, module: String, content: String) -> Result<String, String> {
    // Choose an app-local logs dir:
    let mut dir = tauri::api::path::data_dir().ok_or("No data dir")?;
    dir.push("bobby_dev_mode_logs");
    fs::create_dir_all(&dir).map_err(|e| format!("Failed to create log dir: {e}"))?;

    let ts = Utc::now().format("%Y%m%d-%H%M%S").to_string();
    let safe_profile = profile.replace(|c: char| !c.is_ascii_alphanumeric(), "_");
    let safe_module = module.replace(|c: char| !c.is_ascii_alphanumeric(), "_");
    let filename = format!("devmode_{safe_profile}_{safe_module}_{ts}.log");

    let mut path = PathBuf::from(&dir);
    path.push(filename);

    fs::write(&path, content).map_err(|e| format!("Failed to write log: {e}"))?;

    Ok(path.to_string_lossy().to_string())
}


Add to handler:

.invoke_handler(tauri::generate_handler![
    // ‚Ä¶
    devmode_export_log,
])

B. Add ‚ÄúExport Log‚Äù button in DevModeTab.tsx

Under the output panel (or in controls row):

async function exportLog() {
  if (!output) return;
  try {
    const path = await invoke<string>("devmode_export_log", {
      profile: profileId || "unknown",
      module,
      content: output,
    });
    alert(`Dev Mode log exported:\n${path}`);
  } catch (e: any) {
    setError(String(e));
  }
}


Add button:

<button
  onClick={exportLog}
  disabled={!output}
  className="px-3 py-1 rounded-md bg-slate-800 hover:bg-slate-700 text-xs"
>
  Export Log
</button>


Stick it on the right side of the ‚ÄúConsole Output‚Äù header or in the top row, whatever fits your layout.

What you‚Äôve got now

For Dev Mode:

Live Stream Mode

devmode_stream_module runs python -m bobby_dev_mode.cli ‚Ä¶

Every line from ADB/fastboot prints straight into your React console in real time.

Case-Backed Mode

devmode_run_module uses api_cli.run_module_json

Captures all output, calls save_devmode_run, creates a DEV-‚Ä¶ entry in history

Returns the ticket_id to the UI

Shows up in your Jobs / Case Files view next to imaging/diagnostics

Exportable Logs

devmode_export_log writes a .log file to ‚Ä¶/bobby_dev_mode_logs/

One click from DevModeTab and you‚Äôve got a raw text log path you can archive or attach to tickets

This stitches Dev Mode into the same ecosystem as:

BootForge imaging

Pandora diagnostics

Case Files / PDF reports

All under one roof.

If you want to push even further later, the next killer step would be:

Add a ‚ÄúAttach Dev Mode Case‚Äù dropdown inside the Jobs view so you can cross-link: Imaging Case IMG-‚Ä¶ + Dev Mode Case DEV-‚Ä¶ + Diagnostics Case POST-INSTALL-‚Ä¶ into a single ‚ÄúMaster Ticket‚Äù.

But for now, you‚Äôve got the full ‚ÄúALL‚Äù package wired.

You said:
alll
ChatGPT said:
Thought for 15s

Got it ‚Äî you want the whole thing fused, not just pieces.

So let‚Äôs do what I teased:
Master Tickets that group:

Imaging cases (IMG-‚Ä¶)

Diagnostics (POST-‚Ä¶/BENCH-‚Ä¶)

Dev Mode runs (DEV-‚Ä¶)

Anything else you log later

All under one ‚Äújob‚Äù ID you can click and see the whole story of that device.

I‚Äôll give you concrete building blocks:

Backend: Master Ticket system in history/manager.py

Python API: JSON commands to manage master tickets

Tauri: Commands to talk to that API

JobsTab UI:

List master tickets

See linked cases

Attach current case ‚Üí existing or new master ticket

You can refine styling later; this will work.

1Ô∏è‚É£ Backend: Master Ticket System
A. Extend history/manager.py

Add a new JSON file to track master tickets:

# history/manager.py

import os, json
from datetime import datetime
from typing import Dict, Any, List

BASE_DIR = os.path.join(os.path.dirname(__file__), "storage")
os.makedirs(BASE_DIR, exist_ok=True)

MASTER_FILE = os.path.join(BASE_DIR, "master_tickets.json")

# ... existing save_case, load_case, list_cases ...


def _load_master_tickets() -> List[Dict[str, Any]]:
    if not os.path.isfile(MASTER_FILE):
        return []
    with open(MASTER_FILE, "r", encoding="utf-8") as f:
        return json.load(f)


def _save_master_tickets(tickets: List[Dict[str, Any]]) -> None:
    with open(MASTER_FILE, "w", encoding="utf-8") as f:
        json.dump(tickets, f, indent=2)


def create_master_ticket(
    label: str,
    description: str = "",
    initial_cases: List[str] | None = None,
) -> Dict[str, Any]:
    tickets = _load_master_tickets()
    ts = datetime.utcnow().strftime("%Y%m%d-%H%M%S")
    master_id = f"MT-{ts}"

    ticket = {
        "master_id": master_id,
        "label": label or master_id,
        "description": description or "",
        "created_at": datetime.utcnow().isoformat() + "Z",
        "case_ids": initial_cases or [],
    }
    tickets.append(ticket)
    _save_master_tickets(tickets)
    return ticket


def list_master_tickets() -> List[Dict[str, Any]]:
    return sorted(_load_master_tickets(), key=lambda t: t["created_at"], reverse=True)


def attach_case_to_master(master_id: str, case_id: str) -> Dict[str, Any]:
    tickets = _load_master_tickets()
    found = None
    for t in tickets:
        if t.get("master_id") == master_id:
            found = t
            break
    if not found:
        raise ValueError(f"Master ticket not found: {master_id}")

    if "case_ids" not in found:
        found["case_ids"] = []

    if case_id not in found["case_ids"]:
        found["case_ids"].append(case_id)

    _save_master_tickets(tickets)
    return found


You already have save_case, load_case, list_cases defined earlier.

This gives you:

create_master_ticket(label, description, initial_cases)

list_master_tickets()

attach_case_to_master(master_id, case_id)

2Ô∏è‚É£ Python API: Master Ticket JSON Commands

In your existing phoenix_api_cli.py (the one that already exposes list_cases_json, load_case_json, etc.), add imports + handlers:

# phoenix_api_cli.py

from history.manager import (
    list_cases,
    load_case,
    create_master_ticket,
    list_master_tickets,
    attach_case_to_master,
)

# ... existing CLI handling ...


elif cmd == "list_master_tickets_json":
    tickets = list_master_tickets()
    print(json.dumps(tickets, indent=2))

elif cmd == "create_master_ticket_json":
    # args: label [description]
    label = sys.argv[2] if len(sys.argv) > 2 else ""
    description = sys.argv[3] if len(sys.argv) > 3 else ""
    ticket = create_master_ticket(label, description, [])
    print(json.dumps(ticket, indent=2))

elif cmd == "attach_case_to_master_json":
    # args: master_id case_id
    if len(sys.argv) < 4:
        print(json.dumps({"error": "Need master_id and case_id"}))
        sys.exit(1)
    master_id = sys.argv[2]
    case_id = sys.argv[3]
    ticket = attach_case_to_master(master_id, case_id)
    print(json.dumps(ticket, indent=2))


Now from shell you could do, for example:

python phoenix_api_cli.py list_master_tickets_json
python phoenix_api_cli.py create_master_ticket_json "S22+ Full Rework" "IMG+DEV+Diag bundle"
python phoenix_api_cli.py attach_case_to_master_json MT-... IMG-...

3Ô∏è‚É£ Tauri: Bridge Commands

In src-tauri/src/main.rs you already have run_python(PHOENIX_CLI, ...).

Add:

#[tauri::command]
fn list_master_tickets() -> Result<String, String> {
    // phoenix_api_cli.py list_master_tickets_json
    run_python(PHOENIX_CLI, &["list_master_tickets_json"])
}

#[tauri::command]
fn create_master_ticket(label: String, description: String) -> Result<String, String> {
    // phoenix_api_cli.py create_master_ticket_json <label> <description>
    run_python(PHOENIX_CLI, &["create_master_ticket_json", &label, &description])
}

#[tauri::command]
fn attach_case_to_master(master_id: String, case_id: String) -> Result<String, String> {
    // phoenix_api_cli.py attach_case_to_master_json <master_id> <case_id>
    run_python(
        PHOENIX_CLI,
        &["attach_case_to_master_json", &master_id, &case_id],
    )
}


Then wire them into the invoke_handler!:

.invoke_handler(tauri::generate_handler![
    // existing commands...
    list_cases,
    load_case,
    list_master_tickets,
    create_master_ticket,
    attach_case_to_master,
    // devmode_* etc...
])

4Ô∏è‚É£ JobsTab UI: Master Tickets Panel + Attach Flow

We extend the JobsTab we already built.

A. Extend JobsTab state

In src/tabs/JobsTab.tsx:

type CaseSummary = {
  ticket_id: string;
  timestamp?: string;
  device?: { model?: string };
  health_score?: { overall?: number };
  recipe?: string;
  kind?: string;
};

type MasterTicket = {
  master_id: string;
  label: string;
  description?: string;
  created_at: string;
  case_ids: string[];
};

const [cases, setCases] = useState<CaseSummary[]>([]);
const [selected, setSelected] = useState<string | null>(null);
const [details, setDetails] = useState<any | null>(null);

const [masters, setMasters] = useState<MasterTicket[]>([]);
const [selectedMaster, setSelectedMaster] = useState<string>("");
const [newMasterLabel, setNewMasterLabel] = useState<string>("");
const [newMasterDescription, setNewMasterDescription] = useState<string>("");

B. Load master tickets on mount

Inside useEffect that loads cases, add another fetch or separate one:

useEffect(() => {
  (async () => {
    try {
      const rawCases = await invoke<string>("list_cases");
      setCases(JSON.parse(rawCases));

      const rawMasters = await invoke<string>("list_master_tickets");
      setMasters(JSON.parse(rawMasters));
    } catch (e: any) {
      console.error(e);
    }
  })();
}, []);

C. Attach current case ‚Üí master ticket

Add helper:

async function attachToExistingMaster() {
  if (!selected || !selectedMaster) return;
  try {
    await invoke<string>("attach_case_to_master", {
      masterId: selectedMaster,
      caseId: selected,
    });
    // refresh master tickets list to reflect new case
    const rawMasters = await invoke<string>("list_master_tickets");
    setMasters(JSON.parse(rawMasters));
  } catch (e: any) {
    console.error(e);
  }
}

async function createMasterAndAttach() {
  if (!selected || !newMasterLabel.trim()) return;
  try {
    const raw = await invoke<string>("create_master_ticket", {
      label: newMasterLabel,
      description: newMasterDescription || "",
    });
    const mt = JSON.parse(raw) as MasterTicket;
    await invoke<string>("attach_case_to_master", {
      masterId: mt.master_id,
      caseId: selected,
    });
    const rawMasters = await invoke<string>("list_master_tickets");
    setMasters(JSON.parse(rawMasters));
    setSelectedMaster(mt.master_id);
    setNewMasterLabel("");
    setNewMasterDescription("");
  } catch (e: any) {
    console.error(e);
  }
}

D. Show Master Ticket info for selected case

Compute:

const attachedMasters = masters.filter((mt) =>
  mt.case_ids?.includes(selected || "")
);

E. Layout: add a right-side master ticket panel

Your JobsTab layout was:

Left: cases list

Right: case details JSON

We‚Äôll expand right side to:

top: master ticket info / attach controls

bottom: case JSON

Sketch:

return (
  <div className="grid grid-cols-3 gap-4 h-full">
    {/* LEFT: Case list */}
    <div className="col-span-1 border border-slate-800 rounded-xl p-3 text-xs">
      <h2 className="font-semibold mb-2 text-sm">Cases</h2>
      <div className="space-y-1 max-h-[70vh] overflow-auto">
        {cases.map((c) => (
          <button
            key={c.ticket_id}
            onClick={() => load(c.ticket_id)}
            className={`w-full text-left px-2 py-1 rounded-md hover:bg-slate-900 ${
              selected === c.ticket_id ? "bg-slate-800" : ""
            }`}
          >
            <div className="flex justify-between">
              <span>{c.ticket_id}</span>
              {c.health_score?.overall != null && (
                <span className="text-[10px] text-slate-400">
                  {c.health_score.overall}
                </span>
              )}
            </div>
            <div className="text-slate-400 text-[10px]">
              {c.device?.model || "Unknown"} ¬∑ {c.timestamp}
            </div>
          </button>
        ))}
      </div>
    </div>

    {/* RIGHT: Master + Details */}
    <div className="col-span-2 flex flex-col gap-3">
      {/* Master Ticket controls */}
      <div className="border border-slate-800 rounded-xl p-3 text-xs space-y-2">
        <div className="flex justify-between items-center">
          <div className="font-semibold text-sm">Master Ticket Links</div>
          <div className="text-[11px] text-slate-500">
            Group IMG / DEV / DIAG into one job ID.
          </div>
        </div>

        {selected ? (
          <>
            {attachedMasters.length > 0 ? (
              <div className="text-[11px] text-emerald-300">
                Attached to:{" "}
                {attachedMasters
                  .map((mt) => `${mt.master_id} (${mt.label})`)
                  .join(", ")}
              </div>
            ) : (
              <div className="text-[11px] text-slate-400">
                This case is not attached to any master ticket yet.
              </div>
            )}

            <div className="mt-2 grid grid-cols-2 gap-3">
              {/* Attach to existing */}
              <div>
                <div className="text-[11px] text-slate-400 mb-1">
                  Attach to existing Master Ticket
                </div>
                <div className="flex gap-2">
                  <select
                    className="flex-1 bg-slate-900 border border-slate-700 rounded-md px-2 py-1 text-[11px]"
                    value={selectedMaster}
                    onChange={(e) => setSelectedMaster(e.target.value)}
                  >
                    <option value="">Select‚Ä¶</option>
                    {masters.map((mt) => (
                      <option key={mt.master_id} value={mt.master_id}>
                        {mt.master_id} ‚Äì {mt.label}
                      </option>
                    ))}
                  </select>
                  <button
                    onClick={attachToExistingMaster}
                    disabled={!selectedMaster}
                    className="px-3 py-1 rounded-md bg-slate-800 hover:bg-slate-700 text-[11px]"
                  >
                    Attach
                  </button>
                </div>
              </div>

              {/* Create new + attach */}
              <div>
                <div className="text-[11px] text-slate-400 mb-1">
                  Create new Master Ticket and attach
                </div>
                <div className="flex flex-col gap-1">
                  <input
                    className="bg-slate-900 border border-slate-700 rounded-md px-2 py-1 text-[11px]"
                    placeholder="Label (e.g. S22+ Full Rework)"
                    value={newMasterLabel}
                    onChange={(e) => setNewMasterLabel(e.target.value)}
                  />
                  <div className="flex gap-2">
                    <input
                      className="flex-1 bg-slate-900 border border-slate-700 rounded-md px-2 py-1 text-[11px]"
                      placeholder="Description (optional)"
                      value={newMasterDescription}
                      onChange={(e) =>
                        setNewMasterDescription(e.target.value)
                      }
                    />
                    <button
                      onClick={createMasterAndAttach}
                      disabled={!newMasterLabel.trim()}
                      className="px-3 py-1 rounded-md bg-emerald-600 hover:bg-emerald-500 text-[11px]"
                    >
                      Create + Attach
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </>
        ) : (
          <div className="text-[11px] text-slate-400">
            Select a case on the left to manage its master ticket links.
          </div>
        )}
      </div>

      {/* Case details viewer */}
      <div className="border border-slate-800 rounded-xl p-3 text-xs flex-1 flex flex-col">
        <h2 className="font-semibold mb-2 text-sm">Case Details</h2>
        {details ? (
          <pre className="bg-slate-950 rounded-lg p-2 max-h-[55vh] overflow-auto">
            {JSON.stringify(details, null, 2)}
          </pre>
        ) : (
          <div className="text-slate-400">
            Select a case to view details.
          </div>
        )}
      </div>
    </div>
  </div>
);


Now the flow is:

Imaging run ‚Üí IMG-‚Ä¶ case

Diagnostic bench ‚Üí POST-/BENCH-/whatever case

DevMode run ‚Üí DEV-‚Ä¶ case

In JobsTab:

Click an imaging case ‚Üí attach to new Master Ticket MT-‚Ä¶ labeled ‚ÄúS22+ Full Rework‚Äù

Click the DevMode case for that same device ‚Üí attach it to the same MT-‚Ä¶

Click the diagnostic case ‚Üí attach it too

Then, from the Master Ticket row, you see:

Which master tickets this case belongs to

From your master tickets backend (or a separate listing tab later), you can see all case IDs under MT-‚Ä¶.

What you‚Äôve got now

You‚Äôve basically built your own shop CRM core:

Case Files for every operation:

Imaging

Diagnostics

DevMode

(Anything else you log later)

Master Tickets (MT-‚Ä¶) that group cases into one ‚Äújob‚Äù per device/visit.

UI that lets you:

See every case

See case JSON (health report, dev logs, imaging info)

Attach cases to master tickets

Create new master tickets on the fly

On top of all the earlier stuff:

Dev Mode CLI

Dev Mode UI (profiles + modules)

Live streaming Dev Mode output

Case history

PDF export for diagnostics

Log export for Dev Mode

You‚Äôve basically built the backbone of Bobby‚Äôs repair platform.

If you want to go even wilder later, we can add:

A dedicated Master Tickets tab that shows each MT-‚Ä¶ and all linked cases in one view

Simple customer + device records attached at the master level (so you can see ‚ÄúCustomer X, S22+, all work done‚Äù)